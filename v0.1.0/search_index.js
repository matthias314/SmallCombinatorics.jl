var documenterSearchIndex = {"docs":
[{"location":"#SmallCombinatorics.jl","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.jl","text":"","category":"section"},{"location":"#SmallCombinatorics","page":"SmallCombinatorics.jl","title":"SmallCombinatorics","text":"SmallCombinatorics\n\nThis module contains functions related to enumerative combinatorics.\n\n\n\n\n\n","category":"module"},{"location":"#Partitions","page":"SmallCombinatorics.jl","title":"Partitions","text":"","category":"section"},{"location":"#SmallCombinatorics.partitions","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.partitions","text":"partitions(n::Integer)\n\nReturn an iterator over the partitions of n. A partition of n is a weakly decreasing sequence of positive integers that add up to n. Each partition is of type SmallVector{64,Int8}, but this may change in the future.\n\nSee also partitions(::Integer, ::Integer).\n\nExamples\n\njulia> partitions(3) |> collect\n3-element Vector{SmallVector{64, Int8}}:\n [3]\n [2, 1]\n [1, 1, 1]\n\njulia> partitions(0) |> collect\n1-element Vector{SmallVector{64, Int8}}:\n 0-element SmallVector{64, Int8}\n\n\n\n\n\npartitions(n::Integer, k::Integer)\n\nReturn an iterator over the partitions of n into k parts. A partition of n is a weakly decreasing sequence of positive integers that add up to n. Each partition is of type SmallVector{64,Int8}, but this may change in the future.\n\nSee also partitions(::Integer).\n\nExamples\n\njulia> partitions(7, 3) |> collect\n4-element Vector{SmallVector{64, Int8}}:\n [5, 1, 1]\n [4, 2, 1]\n [3, 3, 1]\n [3, 2, 2]\n\njulia> partitions(7, 0) |> collect\nSmallVector{64, Int8}[]\n\njulia> partitions(0, 0) |> collect\n1-element Vector{SmallVector{64, Int8}}:\n 0-element SmallVector{64, Int8}\n\n\n\n\n\n","category":"function"},{"location":"#Compositions","page":"SmallCombinatorics.jl","title":"Compositions","text":"","category":"section"},{"location":"#SmallCombinatorics.compositions","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.compositions","text":"compositions(n::Integer, k::Integer)\n\nReturn an iterator over the compositions of n of length k. A composition of n of length k is a k-tuple of positive integers that add up to n. Each composition is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also weakcompositions, compositions_cumsum.\n\nExamples\n\njulia> compositions(3, 2) |> collect\n2-element Vector{SmallVector{16, Int8}}:\n [1, 2]\n [2, 1]\n\njulia> compositions(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> compositions(0, 0)  |> collect\n1-element Vector{SmallVector{16, Int8}}:\n 0-element SmallVector{16, Int8}\n\n\n\n\n\n","category":"function"},{"location":"#SmallCombinatorics.compositions_cumsum","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.compositions_cumsum","text":"compositions_cumsum(n::Integer, k::Integer)\n\nReturn an iterator over the cumulative sums of the compositions of n of length k. A composition of n of length k is a k-tuple of positive integers that add up to n. The cumulative sum of such a composition is a vector with k+1 elements, starting with 0 and ending with n. Each vector is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also compositions, weakcompositions_cumsum.\n\nExamples\n\njulia> compositions_cumsum(3, 2) |> collect\n2-element Vector{SmallVector{16, Int8}}:\n [0, 1, 3]\n [0, 2, 3]\n\njulia> compositions_cumsum(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> compositions_cumsum(0, 0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n [0]\n\n\n\n\n\n","category":"function"},{"location":"#SmallCombinatorics.weakcompositions","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.weakcompositions","text":"weakcompositions(n::Integer, k::Integer)\n\nReturn an iterator over the weak compositions of n of length k. A weak composition of n of length k is a k-tuple of non-negative integers that add up to n. Each composition is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also compositions, weakcompositions_cumsum.\n\nExamples\n\njulia> weakcompositions(3, 2) |> collect\n4-element Vector{SmallVector{16, Int8}}:\n [0, 3]\n [1, 2]\n [2, 1]\n [3, 0]\n\njulia> weakcompositions(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> weakcompositions(0, 0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n 0-element SmallVector{16, Int8}\n\n\n\n\n\n","category":"function"},{"location":"#SmallCombinatorics.weakcompositions_cumsum","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.weakcompositions_cumsum","text":"weakcompositions_cumsum(n::Integer, k::Integer)\n\nReturn an iterator over the cumulative sums of the weak compositions of n of length k. A weak composition of n of length k is a k-tuple of non-negative integers that add up to n. The cumulative sum of such a composition is a vector with k+1 elements, starting with 0 and ending with n. Each vector is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also weakcompositions, compositions_cumsum.\n\nExamples\n\njulia> weakcompositions_cumsum(3, 2) |> collect\n4-element Vector{SmallVector{16, Int8}}:\n [0, 0, 3]\n [0, 1, 3]\n [0, 2, 3]\n [0, 3, 3]\n\njulia> weakcompositions_cumsum(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> weakcompositions_cumsum(0, 0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n [0]\n\n\n\n\n\n","category":"function"},{"location":"#Subsets-and-set-compositions","page":"SmallCombinatorics.jl","title":"Subsets and set compositions","text":"","category":"section"},{"location":"","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.jl","text":"When used with a SmallBitSet as first argument, the following functions internally use the function pdep. As discussed in the docstring for pdep, performance is much better if the processor supports the BMI2 instruction set. The same applies to setcompositions with more than two parts, even if the first argument is not a SmallBitSet.","category":"page"},{"location":"#SmallCombinatorics.subsets-Tuple{Integer}","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.subsets","text":"subsets(s::S) where S <: SmallBitSet -> AbstractVector{S}\nsubsets(n::Integer) -> AbstractVector{SmallBitSet{UInt}}\n\nIn the first form, return a vector of length 2^length(s) whose elements are the subsets of the set s.\n\nIn the second form the set s is taken to be SmallBitSet(1:n).\n\nSee also subsets(::Integer, ::Integer).\n\nExamples\n\njulia> subsets(SmallBitSet{UInt8}([3, 5])) |> collect\n4-element Vector{SmallBitSet{UInt8}}:\n SmallBitSet([])\n SmallBitSet([3])\n SmallBitSet([5])\n SmallBitSet([3, 5])\n\njulia> subsets(2) |> collect\n4-element Vector{SmallBitSet{UInt64}}:\n SmallBitSet([])\n SmallBitSet([1])\n SmallBitSet([2])\n SmallBitSet([1, 2])\n\njulia> subsets(2)[2]\nSmallBitSet{UInt64} with 1 element:\n  1\n\n\n\n\n\n","category":"method"},{"location":"#SmallCombinatorics.subsets-Tuple{Integer, Integer}","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.subsets","text":"subsets(s::SmallBitSet, k::Integer)\nsubsets(n::Integer, k::Integer)\n\nIn the first form, return an iterator that yields all k-element subsets of the set s. The element type is the type of s. If k is negative or larger than length(s), then the iterator is empty.\n\nIn the second form the set s is taken to be SmallBitSet(1:n).\n\nSee also subsets(::Integer), setcompositions_parity.\n\nExample\n\njulia> subsets(SmallBitSet{UInt8}(2:2:8), 3) |> collect\n4-element Vector{SmallBitSet{UInt8}}:\n SmallBitSet([2, 4, 6])\n SmallBitSet([2, 4, 8])\n SmallBitSet([2, 6, 8])\n SmallBitSet([4, 6, 8])\n\njulia> subsets(3, 2) |> collect\n3-element Vector{SmallBitSet{UInt64}}:\n SmallBitSet([1, 2])\n SmallBitSet([1, 3])\n SmallBitSet([2, 3])\n\njulia> subsets(3, 4) |> collect\nSmallBitSet{UInt64}[]\n\n\n\n\n\n","category":"method"},{"location":"#SmallCombinatorics.setcompositions","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.setcompositions","text":"setcompositions(s::S, ks::Vararg{Integer,N}) where {S <: SmallBitSet, N}\nsetcompositions(ks::Vararg{Integer,N}) where N\n\nIn the first form, return an iterator that yields all ks-compositions of the set s, that is, all ordered partitions of s into N sets of size ks[1] to ks[N], respectively. The element type is NTuple{N, S}. The partition sizes in ks must be non-negative and add up to length(s).\n\nIn the second form the set s is taken to be SmallBitSet(1:sum(ks)). This gives an iterator over all set compositions of the integer sum(ks).\n\nSee also subsets, setcompositions_parity.\n\nExamples\n\njulia> setcompositions(SmallBitSet([2, 4, 5]), 1, 2) |> collect\n3-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([2]), SmallBitSet([4, 5]))\n (SmallBitSet([4]), SmallBitSet([2, 5]))\n (SmallBitSet([5]), SmallBitSet([2, 4]))\n\njulia> setcompositions(1, 1, 1) |> collect\n6-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([1]), SmallBitSet([2]), SmallBitSet([3]))\n (SmallBitSet([2]), SmallBitSet([1]), SmallBitSet([3]))\n (SmallBitSet([1]), SmallBitSet([3]), SmallBitSet([2]))\n (SmallBitSet([3]), SmallBitSet([1]), SmallBitSet([2]))\n (SmallBitSet([2]), SmallBitSet([3]), SmallBitSet([1]))\n (SmallBitSet([3]), SmallBitSet([2]), SmallBitSet([1]))\n\njulia> setcompositions(SmallBitSet([2, 4, 5]), 1, 0, 2) |> collect\n3-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([2]), SmallBitSet([]), SmallBitSet([4, 5]))\n (SmallBitSet([4]), SmallBitSet([]), SmallBitSet([2, 5]))\n (SmallBitSet([5]), SmallBitSet([]), SmallBitSet([2, 4]))\n\njulia> setcompositions(SmallBitSet()) |> collect\n1-element Vector{Tuple{}}:\n ()\n\n\n\n\n\n","category":"function"},{"location":"#SmallCombinatorics.setcompositions_parity-Tuple{Vararg{Integer}}","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.setcompositions_parity","text":"setcompositions_parity(s::S, ks::Vararg{Integer,N}) where {S <: SmallBitSet, N}\nsetcompositions_parity(ks::Vararg{Integer,N}) where N\n\nIn the first form, return an iterator that yields all ks-compositions of the set s together with the parity of the permutation that puts the elements back into an increasing order. See setcompositions and setcomposition_parity for details. The iterator returns tuples (t, p), where t is of type NTuple{N, S} and the parity p is of type Bool where false means even and true means odd. The partition sizes in ks must be non-negative and add up to length(s).\n\nIn the second form the set s is taken to be SmallBitSet(1:sum(ks)).\n\nSee also setcompositions, setcomposition_parity.\n\nExamples\n\njulia> setcompositions_parity(SmallBitSet([2, 4, 5]), 1, 2) |> collect\n3-element Vector{Tuple{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}}, Bool}}:\n ((SmallBitSet([2]), SmallBitSet([4, 5])), 0)\n ((SmallBitSet([4]), SmallBitSet([2, 5])), 1)\n ((SmallBitSet([5]), SmallBitSet([2, 4])), 0)\n\njulia> all(s == setcomposition_parity(a, b) for ((a, b), s) in setcompositions_parity(1, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#SmallCombinatorics.setcomposition_parity","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.setcomposition_parity","text":"setcomposition_parity(ss::SmallBitSet...) -> Bool\n\nReturn true if an odd number of transpositions is needed to transform the elements of the sets ss into an increasing sequence, and false otherwise. The sets are considered as increasing sequences and assumed to be disjoint.\n\nSee also setcompositions_parity.\n\nExamples\n\njulia> s, t, u = SmallBitSet([2, 3, 8]), SmallBitSet([1, 4, 6]), SmallBitSet([5, 7]);\n\njulia> setcomposition_parity(s, t), setcomposition_parity(s, t, u)\n(true, false)\n\n\n\n\n\n","category":"function"},{"location":"#Permutations","page":"SmallCombinatorics.jl","title":"Permutations","text":"","category":"section"},{"location":"#SmallCombinatorics.permutations","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.permutations","text":"permutations(n::Integer)\n\nReturn an iterator that yields all permutations of the integers from 1 to n.\n\nThe argument n must be between 0 and 16. The identity permutation is returned first. Each permutation is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also permutations_parity_transposition.\n\nExamples\n\njulia> permutations(3) |> collect\n6-element Vector{SmallVector{16, Int8}}:\n [1, 2, 3]\n [2, 1, 3]\n [3, 1, 2]\n [1, 3, 2]\n [2, 3, 1]\n [3, 2, 1]\n\njulia> permutations(0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n 0-element SmallVector{16, Int8}\n\n\n\n\n\n","category":"function"},{"location":"#SmallCombinatorics.permutations_parity_transposition","page":"SmallCombinatorics.jl","title":"SmallCombinatorics.permutations_parity_transposition","text":"permutations_parity_transposition(n::Integer)\n\nReturn an iterator that yields all permutations p of the integers from 1 to n together with some extra data. The first element of the tuple returned is the permutation p. The second element is the parity of p (false for even and true for odd permutations). The third element is a pair (i, j) that indicates the transposition t by which p differs from the previously returned permutation q. (More precisely, the new permutations p is obtained by first applying t and then q.)\n\nThe argument n must be between 0 and 16. The iterator returns the identity permutation first; in this case the transposition pair is set to (0, 0). The true transpositions (i, j) satisfy i < j. Each permutation is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also permutations.\n\nExamples\n\njulia> permutations_parity_transposition(3) |> collect\n6-element Vector{Tuple{SmallVector{16, Int8}, Int64, Tuple{Int64, Int64}}}:\n ([1, 2, 3], 0, (0, 0))\n ([2, 1, 3], 1, (1, 2))\n ([3, 1, 2], 0, (1, 3))\n ([1, 3, 2], 1, (1, 2))\n ([2, 3, 1], 0, (1, 3))\n ([3, 2, 1], 1, (1, 2))\n\njulia> permutations_parity_transposition(0) |> collect\n1-element Vector{Tuple{SmallVector{16, Int8}, Int64, Tuple{Int64, Int64}}}:\n ([], 0, (0, 0))\n\n\n\n\n\n","category":"function"}]
}
